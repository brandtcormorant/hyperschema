const gen = require('generate-object-property')

module.exports = function generateSchema (hyperschema) {
  const types = hyperschema.orderedTypes.filter(({ type }) => !type.primitive)
  const encodersByName = new Map()

  for (let i = 0; i < types.length; i++) {
    const { name, type } = types[i]
    type.preprocess()
    const id = 'encoding' + i
    const encoder = generateEncoder(id, name, type)
    encodersByName.set(name, { encoder, id })
  }

  let str = ''
  str += '// This file is autogenerated by the hyperschema compiler\n'
  str += `// Schema Version: ${hyperschema.version}\n`
  str += '/* eslint-disable camelcase */\n'
  str += '\n'
  str += `const VERSION = ${hyperschema.version}\n`
  str += 'const c = require(\'compact-encoding\')\n'
  str += '\n'
  str += '// eslint-disable-next-line no-unused-vars\n'
  str += 'let version = VERSION\n'

  for (let i = 0; i < types.length; i++) {
    const { name } = types[i]
    const { encoder } = encodersByName.get(name)
    str += encoder
    str += '\n'
  }

  str += 'const EncoderMap = new Map([\n'
  for (let i = 0; i < types.length; i++) {
    const { name } = types[i]
    str += `  ['${name}', ${encodersByName.get(name).id}]`
    if (i !== types.length - 1) str += ',\n'
    else str += '\n'
  }
  str += '])\n\n'

  str += 'function resolve (name, v = VERSION) {\n'
  str += '  const enc = EncoderMap.get(name)\n'
  str += '  if (!enc) throw new Error(\'Encoder not found\' + name)\n'
  str += '  return {\n'
  str += '    preencode (state, m) {\n'
  str += '      version = v\n'
  str += '      enc.preencode(state, m)\n'
  str += '    },\n'
  str += '    encode (state, m) {\n'
  str += '      version = v\n'
  str += '      enc.encode(state, m)\n'
  str += '    },\n'
  str += '    decode (state) {\n'
  str += '      version = v\n'
  str += '      return enc.decode(state)\n'
  str += '    }\n'
  str += '  }\n'
  str += '}\n'
  str += 'resolve.version = VERSION\n'
  str += 'module.exports = resolve\n'

  return str

  function generateEncoder (id, name, type) {
    let str = ''
    const fieldTypes = new Map()

    for (let i = 0; i < type.encodables.length; i++) {
      const enc = type.encodables[i]
      if (!enc.framed && !enc.array) continue

      let typeStr = enc.type.primitive ? gen('c', enc.type.name) : encodersByName.get(enc.fqn).id
      if (enc.array) typeStr = `c.array(${typeStr})`
      if (enc.framed) typeStr = `c.frame(${typeStr})`
      const fieldId = `${id}_${i}`
      fieldTypes.set(enc.name, fieldId)

      str += `// ${name}.${enc.name}\n`
      str += `const ${fieldId} = ${typeStr}\n`
    }
    console.log('FIELD TYPES:', fieldTypes)
    str += '\n'

    const preencode = generateEncode(type, { preencode: true })
    const encode = generateEncode(type)
    const decode = generateDecode(type)
    str += `// ${name}\n`
    str += `const ${id} = {\n`
    str += '  preencode (state, m) {\n'
    str += `    ${preencode}\n`
    str += '  },\n'
    str += '  encode (state, m) {\n'
    str += `    ${encode}\n`
    str += '  },\n'
    str += '  decode (state) {\n'
    str += `    ${decode}\n`
    str += '  }\n'
    str += '}\n'
    return str

    function generateEncode (type, { preencode = false } = {}) {
      const fn = preencode ? 'preencode' : 'encode'
      let str = ''

      str += 'let flags = 0\n'
      for (const optional of type.optionals) {
        str += `    ${vPrefix(optional.version, gen('m', optional.name))} flags |= ${optional.flag}`
        str += '\n'
      }
      str += '\n'

      let bitfield = false
      let optional = false
      for (let i = 0; i < type.encodables.length; i++) {
        const enc = type.encodables[i]
        if (i === type.flagsPosition) {
          str += `    c.uint.${fn}(state, flags)`
          bitfield = true
        }

        if (!enc.type.bool) {
          if (bitfield === true) {
            str += '\n'
            bitfield = false
          }
          if (enc.optional && !optional) {
            str += '\n'
            optional = true
          }

          let prefix = '   '
          if (enc.optional) {
            prefix += ` ${vPrefix(enc.version, gen('m', enc.name))}`
          }

          str += `${prefix} ${getEncoder(enc)}.${fn}(state, ${gen('m', enc.name)}) `
          if (i !== type.encodables.length - 1) str += '\n'
        }
      }
      return str
    }

    function generateDecode (type) {
      let str = ''

      str += 'const res = {}\n'
      for (let i = 0; i < type.encodables.length; i++) {
        const enc = type.encodables[i]
        str += `    ${vPrefix(enc.version)}${gen('res', enc.name)} = ${enc.default}\n`
      }
      str += '\n'

      for (let i = 0; i < type.encodables.length; i++) {
        const enc = type.encodables[i]
        const decodeStr = `${gen('res', enc.name)} = ${getEncoder(enc)}.decode(state)`

        if (i === type.flagsPosition) {
          str += '\n'
          str += '    const flags = state.start < state.end ? c.uint.decode(state) : 0\n'
        }

        if (!enc.optional) {
          str += `    ${decodeStr}\n`
        } else {
          str += `    ${vPrefix(enc.version, `(flags & ${enc.flag}) !== 0`)} ${decodeStr}\n`
        }
      }

      str += '\n'
      str += '    return res'
      return str
    }

    function vPrefix (v, condition) {
      if (v === 1) return condition ? `if (${condition})` : ''
      return condition ? `if ((version >= ${v}) && ${condition})` : `if (version >= ${v}) `
    }

    function getEncoder (enc) {
      if (fieldTypes.has(enc.name)) return fieldTypes.get(enc.name)
      if (enc.type.primitive) return `c.${enc.type.name}`
      return encodersByName.get(enc.fqn).id
    }
  }
}
