const gen = require('generate-object-property')

module.exports = function generateSchema (hyperschema) {
  const types = hyperschema.orderedTypes.filter(({ type }) => !type.primitive)
  const typesByVersion = new Map()

  for (const type of types) {
    type.preprocessEncoding()
  }

  for (let i = 1; i <= hyperschema.version; i++) {
    const typeMap = new Map()
    for (let j = 0; j < types.length; j++) {
      const { type, name } = types[j]  
      typeMap.set(name, 'encoding' + i + '_' + 'v' + i)
    }
    typesByVersion.set(i, typeMap)
  }

  let str = ''
  str += '// This file is autogenerated by the hyperschema compiler\n'
  str += `// Schema Version: ${hyperschema.version}\n`
  str += `const version = ${hyperschema.version}\n`
  str += 'const c = require(\'compact-encoding\')\n'

  for (let i = 0; i < types.length; i++) {
    const { name, type } = types[i]
    str += generateEncoder(encoderMap, encoderMap.get(name), name, type)
    str += '\n'
  }

  str += 'const EncoderMap = new Map([\n'

  for (let i = 0; i < types.length; i++) {
    const { name } = types[i]
    str += `  ['${name}', ${encoderMap.get(name)}]`
    if (i !== types.length - 1) str += ',\n'
    else str += '\n'
  }
  str += '])\n\n'

  str += 'module.exports = function resolve (name) {\n'
  str += '  const enc = EncoderMap.get(name)\n'
  str += '  if (!enc) throw new Error(\'Encoder not found\' + name)\n'
  str += '  return enc\n'
  str += '}\n'

  return str
}

function generateEncoder (encoderMap, id, name, type) {
  let str = ''
  const fieldTypes = new Map()

  for (let i = 0; i < type.encodables.length; i++) {
    const enc = type.encodables[i]
    if (!enc.framed && !enc.array) continue

    let typeStr = enc.type.primitive ? enc.type.name : encoderMap.get(enc.fqn)
    if (enc.array) typeStr = `c.array(${typeStr})`
    if (enc.framed) typeStr = `c.frame(${typeStr})`
    const fieldId = `${id}_${i}`
    fieldTypes.set(enc.name, fieldId)

    str += `// ${name}.${enc.name}\n`
    str += `const ${fieldId} = ${typeStr}\n`
  }
  str += '\n'

  const preencode = generateEncode(type, { preencode: true })
  const encode = generateEncode(type)
  const decode = generateDecode(type)
  str += `// ${name}\n`
  str += `const ${id} = {\n`
  str += '  preencode (state, m) {\n'
  str += `    ${preencode}\n`
  str += '  },\n'
  str += '  encode (state, m) {\n'
  str += `    ${encode}\n`
  str += '  },\n'
  str += '  decode (state) {\n'
  str += `    ${decode}\n`
  str += '  }\n'
  str += '}\n'
  return str

  function generateEncode (type, { preencode = false } = {}) {
    const fn = preencode ? 'preencode' : 'encode'
    let str = ''

    str += 'let flags = 0\n'
    for (const optional of type.optionals) {
      str += `    if (m.${optional.name}) flags |= ${optional.flag}`
      str += '\n'
    }
    str += '\n'

    let bitfield = false
    let optional = false
    for (let i = 0; i < type.encodables.length; i++) {
      const enc = type.encodables[i]

      if (i === type.flagsPosition) {
        str += `    c.uint.${fn}(state, flags)`
        bitfield = true
      }

      if (!enc.type.bool) {
        if (bitfield === true) {
          str += '\n'
          bitfield = false
        }
        if (enc.optional && !optional) {
          str += '\n'
          optional = true
        }
        const prefix = enc.optional ? `    if (m.${enc.name})` : '   '
        str += `${prefix} ${getEncoder(enc)}.${fn}(state, m.${enc.name}) `
        if (i !== type.encodables.length - 1) str += '\n'
      }
    }
    return str
  }

  function generateDecode (type) {
    let str = ''

    str += 'const res = {\n'
    for (let i = 0; i < type.encodables.length; i++) {
      const enc = type.encodables[i]
      str += `      ${enc.name}: ${enc.default}`
      if (i !== type.encodables.length - 1) str += ','
      str += '\n'
    }
    str += '    }\n'

    for (let i = 0; i < type.encodables.length; i++) {
      const enc = type.encodables[i]
      const decodeStr = `res.${enc.name} = ${getEncoder(enc)}.decode(state)`

      if (i === type.flagsPosition) {
        str += '\n'
        str += '    const flags = state.start < state.end ? c.uint.decode(state) : 0\n'
      }

      if (!enc.optional) {
        str += `    ${decodeStr}\n`
      } else {
        str += `    if ((flags & enc.flag) !== 0) ${decodeStr}\n`
      }
    }

    str += '\n'
    str += '    return res'
    return str
  }

  function getEncoder (enc) {
    if (enc.type.primitive) return `c.${enc.type.name}`
    if (fieldTypes.has(enc.name)) return fieldTypes.get(enc.name)
    return encoderMap.get(enc.fqn)
  }
}
